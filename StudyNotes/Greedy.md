> [이코테 동영상](https://youtu.be/2zjoKjt97vQ) 보고 정리하는 파이썬 기본 알고리즘 

## Greedy Algorithm 

- `현재 상황에서 지금 당장 좋은 것만 고르는 방법`
- 매 순간 가장 좋은 것만 선택하고 이후에 미칠 영향은 고려하지 X 
- 현재 상황에 가장 좋아보이는 것만을 선택해도 문제를 풀 수 있는가? 
- 창의력(문제를 풀 수 있는 아이디어) 필요 
- "가장 큰 순서대로", "가장 작은 순서대로" 등의 기준 제시 
- 정렬 알고리즘과 짝을 이뤄 같이 출제되는 경향 O
- **정당성 분석**이 중요 
  - 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는가? 
- 문제 유형을 바로 파악하기 어렵다면 Greedy 의심해보기! 

### Greedy 해결 방법 
1. 선택 절차 : 현재 상태에서 최적의 해답 선택 
2. 적절성 검사 : 선택된 해가 문제의 조건 만족하는지 검사 
3. 해답 검사 : 문제가 해결되었는지 검사. 해결되지 않은 경우 선택 절차부터 과정 반복 

### Greedy 적용하기 위한 문제의 2가지 조건 
1. 탐욕적인 선택 속성 : 앞의 선택이 이후의 선택에 영향 X 
2. 최적 부분 구조 : 문제의 최적해가 부분 문제에 대한 최적해로 구성

> [참고 블로그](https://hanamon.kr/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%83%90%EC%9A%95%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-greedy-algorithm/)

</br> 

 ## Implementation Algorithm
 
- 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정 
- 풀이를 떠올리는 것은 쉽지만 코드로 옮기기 어려움😭
- 예시 
  - 알고리즘은 간단한데 코드가 긴 문제 
  - 실수 연산 (특정 소수점까지 출력하는 문제) 
  - 문자열을 특정한 기준에 따라서 끊어 처리해야 하는 문제 - python이 상대적으로 사용하기 쉬움
  - 적절한 라이브러리를 사용하는 문제 - ex) 순열&조합 찾는 문제 
- **완전 탐색** : 모든 경우의 수를 다 계산하는 해결 방법 
- **시뮬레이션** : 문제에서 제시한 알고리즘 한 단계씩 직접 수행
- 많은 연습이 필요함 
- 일반적으로 2차원 공간은 **행렬**의 의미로 사용됨 
- 시뮬레이션과 완전 탐색에서는 **방향벡터**가 자주 활용됨 
  ```python 
  # 동 북 서 남 
  dx = [0, -1, 0, 1]
  dy = [1, 0, -1, 0] 
  
  # 현재 위치 
  x, y = 2, 2
  
  for i in range(4):
    nx = x + dx[i]
    ny = y + dy[i]
    print(nx, ",", ny) 
    
  # 결과 
  # 2 , 3 / 1 , 2 / 2 , 1 / 3 , 2
  ```
